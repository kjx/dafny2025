\section{Introduction}

In the last 20 years, formal methods moved from esoteric research
topic~\cite{CoqTute11} to a set of increasingly practical tools
\cite{alloybook,tlabook,spinbook,dafny2023}.  This is also the case in
programming language design, where formal definitions of operational
semantics, type systems, and soundness proofs are \textit{de rigeur}
for research languages, but also being applied to languages used in
practice \cite{RustBelt18,djpRust}.  During this time, a spectrum of
accepted tools and approaches to formal verification have emerged,
such as e.g. the Syntactic Approach to Type Soundness
\cite{wright_syntactic_1994} as embodied in Pierce's "Types and
Programming Languages" \cite{pierce_types_2002}.  Based on typed
lambda calculi, these seem well suited to garbage-collected functional
languages. Indeed, key features of object-oriented languages have been
formalised and verified as functional subsets
\cite{IgaPieWadTOPLAS01}.
 
In this short paper, we describe our attempts to revisit an important
yet obscure historical contribution to software verification:
\textit{local stores}. Our presentation here draws heavily upon Mark
Utting's 1995 paper \textit{Reasoning about Aliasing} we encourage
readers eager for more details than we can offer here to consult his
work \cite{utting1995,utting1998}.  We study local stores in the
context of Dafny, primarily because Dafny was the verification tool
with which we had the most experience
\cite{MPTP,learn2024,flags2024,dafnydala2024}.

The next section describes local stores in more detail, and then we go
on to consider how local stores could be modelled in Dafny; how they
relate to desmesnes, regions, and Dafny's dynamic frames; and
introduce our work in progress on using nested local stores to model
ownership types.  Finally we speculate on how explicit local stores,
or licit object ownership, could better support generating Rust code
from Dafny programs.
